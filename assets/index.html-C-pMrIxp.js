import{_ as i,c as t,f as p,o as e}from"./app-1Weo8reD.js";const o={};function r(a,l){return e(),t("div",null,l[0]||(l[0]=[p('<p>HTTPS（超文本传输安全协议）是HTTP协议的安全版本，它通过在 HTTP 协议上添加 SSL/TLS 层来实现数据的加密和安全传输。HTTPS 的核心在于采用 对称加密 和 非对称加密 的结合使用。</p><h2 id="不进行加密" tabindex="-1"><a class="header-anchor" href="#不进行加密"><span>不进行加密</span></a></h2><p>明文传输：在客户端和服务器数据传输过程中，可以获取到传输的账号密码和其他数据，非常不安全。</p><p>我们可以借助 抓包工具，如 Charles，Fiddler 等工具，对网络请求进行抓包，获取到传输的数据。</p><h2 id="对称加密" tabindex="-1"><a class="header-anchor" href="#对称加密"><span>对称加密</span></a></h2><p>对称加密：使用相同的密钥进行加密和解密。发送方和接收方必须在通信之前共享这个密钥。</p><p><strong>加密步骤</strong></p><ol><li>密钥生成：发送方生成一个随机密钥（对称密钥）。</li><li>数据加密：使用对称密钥对数据进行加密，生成密文。</li><li>数据传输：将密文发送给接收方。</li><li>数据解密：接收方使用相同的对称密钥对密文进行解密，恢复原始数据。</li></ol><p><strong>优点</strong></p><ul><li>速度快：加密和解密速度快，效率高。</li><li>计算资源消耗低：实现简单，不需要复杂的密钥交换过程。</li></ul><p><strong>缺点</strong></p><ul><li>密钥传输问题：密钥的安全性依赖于密钥的保密性，密钥在传输过程中可能被窃取。</li><li>扩展性差：每对通信方都需要一个独立的密钥，随着通信方数量的增加，密钥管理变得复杂。</li></ul><h2 id="非对称加密" tabindex="-1"><a class="header-anchor" href="#非对称加密"><span>非对称加密</span></a></h2><p>非对称加密：使用一对密钥，公钥和私钥。公钥可以公开，任何人都可以用它加密信息；而私钥则必须保密，只有密钥的拥有者才能用它解密信息。</p><p><strong>加密步骤</strong></p><ul><li><ol><li>密钥对生成：用户生成一对密钥，包括公钥和私钥。</li></ol></li><li><ol start="2"><li>公钥分发：用户将公钥发送给需要与之通信的其他方。</li></ol></li><li><ol start="3"><li>数据加密：发送方使用接收方的公钥对数据进行加密，生成密文。</li></ol></li><li><ol start="4"><li>数据传输：将密文发送给接收方。</li></ol></li><li><ol start="5"><li>数据解密：接收方使用自己的私钥对密文进行解密，恢复原始数据。</li></ol></li></ul><p><strong>优点</strong></p><ul><li>安全性高：即使公钥被公开，只有拥有私钥的人才能解密信息，避免了密钥在传输过程中的泄露。</li></ul><p><strong>缺点</strong></p><ul><li>速度慢：非对称加密算法的计算复杂度较高，处理速度较慢，不适合大规模数据的加密。</li><li>计算资源消耗大：相较于对称加密，非对称加密需要更多的计算资源。</li></ul><h2 id="https-的加密机制" tabindex="-1"><a class="header-anchor" href="#https-的加密机制"><span>HTTPS 的加密机制</span></a></h2><p>HTTPS 结合了 对称加密 和 非对称加密 的优点，通过以下步骤实现数据的安全传输：</p><p><strong>握手过程</strong></p><p>当客户端与服务器建立HTTPS连接时，首先进行SSL/TLS握手。在握手过程中，使用非对称加密来交换密钥，具体步骤如下：</p><ol><li><p>客户端 ClientHello</p><p>客户端向服务器发送“Hello”消息，包含支持的SSL/TLS版本、加密算法列表和一个随机数（Client Random）。</p></li><li><p>服务器 ServerHello</p><p>服务器响应“Hello”消息，选择SSL/TLS版本和加密算法，并发送自己的随机数（Server Random）。</p></li><li><p>服务器证书</p><p>服务器将数字证书发送给客户端，证书中包含服务器的公钥。客户端验证证书的合法性，如果证书无效，则握手失败。</p></li><li><p>密钥交换</p><p>客户端生成一个随机密钥（会话密钥），并使用服务器的公钥对该密钥进行加密。这个加密后的会话密钥称为“预主密钥”（Pre-Master Secret）。</p><p>客户端将加密后的预主密钥发送给服务器。</p></li><li><p>服务器解密</p><p>服务器使用自己的私钥对预主密钥进行解密，得到会话密钥。</p></li><li><p>会话密钥生成</p><p>客户端和服务器使用预主密钥以及之前交换的随机数（Client Random 和 Server Random）生成一组对称加密的会话密钥。这些会话密钥将用于后续的数据加密和解密。</p></li><li><p>加密确认</p><p>客户端发送一条消息，表明后续的消息将使用会话密钥进行加密。</p><p>服务器收到后，发送一条确认消息，表明它也将使用会话密钥进行加密。</p></li><li><p>安全链接建立</p><p>握手完成，客户端和服务器之间的通信将使用会话密钥进行加密和解密，确保数据传输的安全性。</p></li></ol><p><strong>数据传输</strong></p><p>在握手完成后，客户端和服务器之间的所有数据传输都将使用对称加密进行加密和解密。</p><ul><li><ol><li>数据加密：发送方使用会话密钥对要发送的数据进行加密，生成密文。</li></ol></li><li><ol start="2"><li>数据传输： 将加密后的密文发送给接收方。</li></ol></li><li><ol start="3"><li>数据解密：接收方使用相同的会话密钥对收到的密文进行解密，恢复原始数据。</li></ol></li></ul>',28)]))}const n=i(o,[["render",r],["__file","index.html.vue"]]),h=JSON.parse('{"path":"/Computer/r8g2shzj/","title":"HTTPS原理解析","lang":"zh-CN","frontmatter":{"title":"HTTPS原理解析","author":"耶温","createTime":"2024/05/10 16:02:55","permalink":"/Computer/r8g2shzj/","tags":["计算机基础","网络安全","HTTPS"]},"headers":[],"readingTime":{"minutes":4.39,"words":1317},"git":{"updatedTime":1732258650000,"contributors":[{"name":"Yevin Yu","email":"yuwb0521@outlook.com","commits":2,"avatar":"https://avatars.githubusercontent.com/Yevin Yu?v=4","url":"https://github.com/Yevin Yu"}]},"filePathRelative":"notes/Computer/HTTPS原理解析.md","bulletin":false}');export{n as comp,h as data};
